getgenv().AuthKey = "HUGE_yr9lEktNGFjD"
getgenv().LoadSettings = {
    Example_Setting = Example_Value
}
loadstring(game:HttpGet("https://HugeGames.io/ps99"))()

local replicatedStorage = game:GetService("ReplicatedStorage")
local merchantRequestPurchase = replicatedStorage:WaitForChild("Network"):WaitForChild("Merchant_RequestPurchase")

local function autoMerchant()
    while true do
        for i = 1, 8 do
            local args = {
                [1] = "MiningMerchant",
                [2] = i
            }
            
            merchantRequestPurchase:InvokeServer(unpack(args))
            wait(1) -- Espera 1 segundo entre as compras para evitar sobrecarga
        end
        wait(10) -- Espera 10 segundos antes de reiniciar o loop
    end
end

-- Inicia o auto-merchant em uma nova coroutine
coroutine.wrap(autoMerchant)()


wait(10)
local Pl = game:GetService("Players").LocalPlayer
local RS = game:GetService("ReplicatedStorage")

local savemodule = require(RS.Library.Client.Save)
local FileSave = savemodule.Get(Pl)

local itemOrder = {"Mining TNT Crate", "Mining TNT", "Mining Bomb"}

local initialPosition = Pl.Character and Pl.Character.PrimaryPart.Position or Vector3.new(0, 0, 0)
local stationaryTime = 0
local AmountTNT = 10 -- quantidade de TNT
local AmountTimer = 15 -- quantidade de tempo pra proxima verificação
local proximityThreshold = 2 -- quantidade de studs (maximo 5)
local CooldownTNT = 0.8 -- delay pra jogar 1 tnt atras da outra

local G = getgenv()
G.AutoTNT = true

while G.AutoTNT do
    task.wait(1)
    local currentPosition = Pl.Character and Pl.Character.PrimaryPart.Position or Vector3.new(0, 0, 0)

    if (currentPosition - initialPosition).magnitude <= proximityThreshold then
        stationaryTime = stationaryTime + 1
    else
        stationaryTime = 0
        initialPosition = currentPosition
    end

    if stationaryTime >= 5 then
        for i, itemName in ipairs(itemOrder) do
            if not G.AutoTNT then break end
            local hasEnough = false
            for IdItem, tb in pairs(FileSave.Inventory.Consumable) do
                if not G.AutoTNT then break end
                if tb.id == itemName and tb._am >= 2 then
                    RS.Network.Consumables_Consume:InvokeServer(IdItem, 1)
                    task.wait(CooldownTNT)
                    RS.Network.Consumables_Consume:InvokeServer(IdItem, 1)
                    hasEnough = true
                    break
                end
            end
            if hasEnough then
                break
            end
        end
        stationaryTime = 0
    end
end


wait(5)
local save = require(game.ReplicatedStorage.Library.Client.Save)
local remote = game:GetService("ReplicatedStorage")
for _, v in ipairs({"Network", "PetCraftingMachine_Craft"}) do
    remote = remote:WaitForChild(v)
end

local config = {
    machineName = "MiningCraftMachine",
    extraArgs = { shiny = false, pt = 0 },
    delayBetweenCrafts = 1,
    delayBetweenCycles = 3,
    hugeInterval = 600,
    tiers = {
        { name = "Amethyst Gem", qtyField = "_am" },
        { name = "Rainbow Gem",  qtyField = "_am" },
        { name = "Quartz Gem",   qtyField = "_am" },
        { name = "Topaz Gem",    qtyField = "_am" },
        { name = "Onyx Gem",     qtyField = "_am" },
    },
    craftNumbers = {
        [1] = 4,
        [2] = 5,
        [3] = 6,
        [4] = 7,
    }
}

local function getInventory()
    local saveInstance = require(game.ReplicatedStorage.Library.Client.Save).Get()
    return saveInstance and saveInstance.Inventory and saveInstance.Inventory.Misc or {}
end

local function findGemItem(inventoryMisc, gemName)
    for _, item in pairs(inventoryMisc) do
        if item.id == gemName then
            return item
        end
    end
    return nil
end

local lastHugeTime = os.clock()

while true do
    local currentTime = os.clock()
    local inventory = getInventory()

    if currentTime - lastHugeTime >= config.hugeInterval then
        local onyxTier = config.tiers[#config.tiers]
        while true do
            inventory = getInventory()
            local onyxItem = findGemItem(inventory, onyxTier.name)
            local stock = (onyxItem and onyxItem[onyxTier.qtyField] or 0)
            local totalCraftable = math.floor(stock / 10)
            if totalCraftable < 1 then
                break
            end
            local craftAmount = math.min(totalCraftable * 10, 1000)
            local args = {
                [1] = config.machineName,
                [2] = 8,
                [3] = craftAmount,
                [4] = config.extraArgs
            }
            remote:InvokeServer(unpack(args))
            wait(config.delayBetweenCrafts)
        end
        lastHugeTime = os.clock()
    else
        for i = 1, #config.tiers - 1 do
            local currentTier = config.tiers[i]
            local nextCraft = config.craftNumbers[i]
            local item = findGemItem(inventory, currentTier.name)
            if item then
                local stock = item[currentTier.qtyField] or 0
                local totalCraftable = math.floor(stock / 10)
                while totalCraftable > 0 do
                    local craftAmount = math.min(totalCraftable * 10, 1000)
                    local args = {
                        [1] = config.machineName,
                        [2] = nextCraft,
                        [3] = craftAmount,
                        [4] = config.extraArgs
                    }
                    remote:InvokeServer(unpack(args))
                    wait(config.delayBetweenCrafts)
                    inventory = getInventory()
                    item = findGemItem(inventory, currentTier.name)
                    stock = (item and item[currentTier.qtyField] or 0)
                    totalCraftable = math.floor(stock / 10)
                end
            end
        end
        wait(config.delayBetweenCycles)
    end
end
